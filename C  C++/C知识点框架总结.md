
	内存：
		内存管理方法：栈、堆、代码段(.txt)、数据段（.data）、bss段(.bss)
			栈：
				自动：编译器自动申请和释放，如局部变量的管理。
				连续：申请一个内存后接着申请下一个
				空间小：注意申请数组空间大小（比堆小）
				栈溢出情况：数组定义过大、递归深度太深容易使栈溢出
				动态局部变量的生命周期和作用域：被定义的局部函数内部，局部函数结束，资源释放，局部变量消失
				静态局部变量的生命周期和和作用域，如同全局变量。
			堆：
				手动：程序员手动申请（malloc）和释放（free）
				非连续：有断层
				空间大：可申请很大一块区域（比栈大）
				堆溢出：分配空间太大
				生命周期和作用域：malloc开始、free结束
			
			代码段（.code）：
				函数、字符串常量、const修饰的变量const char * p = "linux";
				
			数据段（.data）
				存显示初始化非0的放全局变量、静态局部变量
				
			bss段（.bss）
				初始化为0的数据段
				存未显示初始化或显示初始化为0的全局变量和静态局部变量
				
		内存取地址方法：大小端、结构体对齐
			大小端：
				大端：
					访问顺序：从低地址访问 0 1 2 3 ... 地址
					内存高低位： 0001（1存在低位） 1000（1存在高位）
					小端：低地址放低位 3210
								   0001
					反则大端
			1.问题？如何确定机器的大小端
				#include <stdio.h>
				union un
				{
					int i;
					char c;
				};

				int main(void)
				{
					union un u = {.i = 1};
					if (u.c == 1) printf("little\n");
					else printf("big\n");

					return;
				}
				
		计算机最小计算单位：位

	变量：
		指针、字符串(ASCII)、数组（sizeof、strlen）、共用体（union）、结构体（typedef、struct）、枚举（enum）、宏定义（define）
		1.指针注意事项：只定义不初始化会为野指针，指向不可指向的地址，指向不存在的地址。使用指针前先判断是否为空。
		2.字符串表示方法
			2.1 由字符组成以'\0'为结束符。char *p = "linux"; 字符指针p指向"linux"存储区，字符串"linux"长度5，占用空间6byte,结束符'\0'，"linux"值是'l'的地址
			2.2 char p[] = {'l','i','n','u','x','\0'}; p为数组占用6byte。
			2.3 sizeof（）字面量，查看类型和变量占用内存大小。strlen（）计算字符串长度不报考'\0',
		3.共用体：成员变量共用一块内存，解析方式（取值长度）不同，占用成员变量最大的内存
		4.结构体：将多个不同类型变量放到一起，一般按照4字节（32位机）对齐取值
		5.宏定义：用来替换单个东西
		5.枚举：用来替换多个有关联的东西
			
	函数：
		字符串函数、递归函数、函数库（数学库函数）
		存储类、作用域、生命周期、链接属性
		1.字符串函数 
			2.1处理：strcpy、strncpy、strcat、strncat
			2.2比较：strcmp、strncmp、strsrt
			2.3内存：memset、memcpy、memcmp
			处理字符串注意结束符'\0'是否被赋值，已经赋值结束后剩余部分是否清零

	修饰符（关键字）：
		auto、static、register、const、voliate、extern、restrict、typedef
		
	程序执行过程：
		预处理（宏（define））、编译、汇编、链接（链接库）
		
	数据结构：
		链表（link）、栈（stack）、队列（queue）、二叉树（tree）
		
	算法：
		查找（顺序、二分）、排序（二分、冒泡、归并、快排）
		时间和空间效率
		
	系统编程与网络编程：

	刷题：
		剑指

	项目：



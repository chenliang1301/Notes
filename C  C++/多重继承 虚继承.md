## 多重继承
- 一个类有多个父类
- 子类拥有所有父类的成员变量和函数
- 子类对象可以当做任意父类对象使用

# 规则

```cpp
#include <iostream>
#include <string>

using namespace std;

class BaseA
{
	int ma;
public:
	BaseA(int a)
	{
		ma =a;
	}
	int getA()
	{
		return ma;
	}
};

class BaseB
{
	int mb;
public:
	BaseB(int b)
	{
		mb = b;
	}
	int getB()
	{
		return mb;
	}	
};

class Derived : public BaseA, public BaseB
{
	int mc;
public:
	Derived(int a, int b, int c) : BaseA(a) , BaseB(b)
	{
		mc = c;
	}
	int getC()
	{
		return mc;
	}
	void print()
	{
		cout << "ma = " << getA() << "."
			 << "mb = " << getB() << "."
			 << "mc = " << getC() << "." << endl;
	}
};
int main()
{
    cout << "sizeof(Derived) = " << sizeof(Derived) << endl;//12
	
	Derived d(1, 2, 3);
	
	d.print();
	
	cout << "d.getA() = " << d.getA() << endl;
	cout << "d.getB() = " << d.getB() << endl;
	cout << "d.getC() = " << d.getC() << endl;
	
	BaseA* pa = &d; //父类指针指向子类对象
	BaseB* pb = &d;
	
	cout << "pa->getA() = " << pa->getA() << endl;
	cout << "pa->getB() = " << pb->getB() << endl;
	
	void* paa = pa;
	void* pbb = pb;
	
	if(paa == pbb)
	{
		cout << "Pointer to the same object" << endl;
	}
	else
	{
		cout << "Error" << endl;
	}
	
	cout << "pa = " << pa << endl;
	cout << "pb = " << pb << endl;
	cout << "paa = " << paa << endl;
	cout << "pbb = " << pbb << endl;
	
	return 0;
	
}

```

> sizeof(Derived) = 12
ma = 1.mb = 2.mc = 3.
d.getA() = 1
d.getB() = 2
d.getC() = 3
pa->getA() = 1
pa->getB() = 2
Error
pa = 0x7ffd0842e5b4
pb = 0x7ffd0842e5b8
paa = 0x7ffd0842e5b4
pbb = 0x7ffd0842e5b8


## 多重继承得到的对象可能拥有“不同的指针”
## 多重继承成关系出现闭合式产生数据冗余
## 解决：虚继承（virtual）

```cpp
#include <iostream>
#include <string>

using namespace std;

class People
{
	string m_name;
	int m_age;
public:
	People(string name, int age)
	{
		m_name = name;
		m_age = age;
	}
	void print()
	{
		cout << "Name = " << m_name << "."
			<< "Age = " << m_age << "." << endl;
	}
};

class Teacher : virtual public People
{
public:
	Teacher(string name, int age) : People(name, age)
	{
		
	}
};

class Student : virtual public People
{
public:
	Student(string name, int age) : People(name, age)
	{
		
	}
};

class Doctor : public Teacher, public Student
{
public:
	Doctor(string name, int age) : Teacher(name, age), Student(name, age), People(name, age)
	{
		
	}	
};

int main()
{
    Doctor d("Delphi", 33);
	d.print();
    return 0;
}

```
## 多继承问题
- 同一对象的地址不同
- 虚继承可以解决数据冗余
- 使架构出现问题

## 多重继承可能产生多个虚函数表指针
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200627213050370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjE3Mzk0OA==,size_16,color_FFFFFF,t_70)

```cpp
#include <iostream>
#include <string>

using namespace std;

class BaseA
{
public:
	virtual void funcA()
	{
		cout << "BaseA::funcA()" << endl;
	}
};

class BaseB
{
public:
	virtual void funcB()
	{
		cout << "BaseB::funcB()" << endl;
	}
};

class Derived : public BaseA, public BaseB
{
	
};

int main()
{
	Derived d;
	BaseA* pa = &d;
	BaseB* pb = &d;
	BaseB* pbe = (BaseB*)pa;
	//BaseB* pbb = (BaseB*)pa;error
	BaseB* pbb = dynamic_cast<BaseB*>(pa);//对结果进行修正
	
	cout << "sizeof(d) = " << sizeof(d) << endl;
	
	pa->funcA();
	
	pb->funcB();
	
	pbb->funcB();
	
    
	cout << "pa = " << pa << endl;
	cout << "pb = " << pb << endl;
	cout << "pbe = " << pbe << endl;
	cout << "pbb = " << pbb << endl;
	
    return 0;
}

```
sizeof(d) = 16
BaseA::funcA()
BaseB::funcB()
BaseB::funcB()
pa = 0x7ffea54baa90
pb = 0x7ffea54baa98
pbe = 0x7ffea54baa90
pbb = 0x7ffea54baa98

## 遇到虚函数的强制类型转换用（dynamic_cast<type*>(a)）

## 多重继承
- 单继承+多接口


```cpp
#include <iostream>
#include <string>

using namespace std;

class Base
{
protected:
	int mi;
public:
	Base(int i)
	{
		mi = i;
	}
	int getI()
	{
		return mi;
	}
	bool equal(Base* obj)
	{
		return (this == obj);
	}
};

class Interface1
{
public:
	virtual void add(int i) = 0;
	virtual void minus(int i) = 0;
};

class Interface2
{
public:
	virtual void mutiply(int i) = 0;
	virtual void divide(int i) = 0;
};

class Derived : public Base, public Interface1, public Interface2
{
public:
	Derived(int i) : Base(i)
	{
	}
	void add(int i)
	{
		mi += i;
	}
	void minus(int i)
	{
		mi -= i;
	}
	void mutiply(int i)
	{
		mi *= i;
	}
	void divide(int i)
	{
		if(i!=0)
		{
			mi /= i;
	}	}
};

int main()
{
	Derived d(100);
	Derived* p = &d;
	Interface1* pInt1 = &d;
	Interface2* pInt2 = &d;
	
	cout << "p->getI() = " << p->getI() << endl;//100
	
	pInt1->add(10);
	pInt2->divide(11);
	pInt1->minus(5);
	pInt2->mutiply(8);
	
	
	cout << "p->getI() = " << p->getI() << endl; //40
	
	cout << "pInt1 == p : " << p->equal(dynamic_cast<Base*>(pInt1)) << endl;//dynamic_cast<Base*>(pInt1) 指针转换为期待对象
	cout << "pInt2 == p : " << p->equal(dynamic_cast<Base*>(pInt2)) << endl;
	
	
    return 0;
}

```
## 一些有用的工程建议
- 先继承自一个父类，然后实现多个接口
- 父类中提供equal（）成员函数
- equal（）成员函数用于判断指针是否指向当期那对象
- 与多重继承相关的强制类型转换用dynamic_cast完成

## 总结
- 多重继承可能出现多个虚函数表指针
- 与多继承相关的强制类型转换用dynamic_cast完成
- 工程开发中采用“但继承多接口”方式使用多继承
- 父类提供成员函数用于判断指针是否指向当前对象



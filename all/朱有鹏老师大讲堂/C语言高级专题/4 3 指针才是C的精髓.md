# 4.3.指针才是C的精髓

《C语言高级专题第3部分-4.3.指针才是C的精髓》

课程特点：深入浅出、具有可学习性、实例来说话

第一部分、章节目录
4.3.1.指针到底是什么？
4.3.2.指针带来的一些符号的理解
4.3.3.野指针问题
4.3.4.const关键字与指针
4.3.5.深入学习一下数组
4.3.6.指针与数组的天生姻缘
4.3.7.指针与强制类型转换
4.3.8.指针、数组与sizeof运算符
4.3.9.指针与函数传参
4.3.10.输入型参数与输出型参数

第二部分、章节介绍
4.3.1.指针到底是什么？
	本节深入剖析指针的本质，指出指针全称指针变量，强调指针其实也是变量的一种，和普通变量并没有本质分别。这个是大家理解关于指针的更高深问题的基础。
4.3.2.指针带来的一些符号的理解
	本节重点讲解指针符号*和取地址符&，及其在指针定义和解引用时的理解。重点是指针符号在定义同时初始化和定义后再次赋值、解引用时各种符号的理解。
4.3.3.野指针问题
	本节首先介绍什么是野指针以及野指针造成的原因和后果，然后重点讲述如何防止野指针的出现，希望大家能养成良好的使用指针的习惯，避免出现野指针导致程序运行时错误。
4.3.4.const关键字与指针
	本节讲述const关键字的用法，重点是const关键字修饰指针的4种常见格式，及其理解方法。通过本节学习希望大家掌握const关键字在修饰指针时的用法。
4.3.5.深入学习一下数组
4.3.6.指针与数组的天生姻缘
4.3.7.指针与强制类型转换
4.3.8.指针、数组与sizeof运算符
4.3.9.指针与函数传参
4.3.10.输入型参数与输出型参数

第三部分、随堂记录

4.3.1.指针到底是什么？
4.3.1.1、指针变量和普通变量的区别
(1)首先必须非常明确：指针的实质就是个变量，它跟普通变量没有任何本质区别。指针完整的名字应该叫指针变量，简称为指针。
4.3.1.2、为什么需要指针？
(1)指针的出现是为了实现间接访问。在汇编中都有间接访问，其实就是CPU的寻址方式中的间接寻址。
(2)间接访问（CPU的间接寻址）是CPU设计时决定的，这个决定了汇编语言必须能够实现间接寻址，又决定了汇编之上的C语言也必须实现简介寻址。
(3)高级语言如Java、C#等没有指针，那他们怎么实现间接访问？答案是语言本身帮我们封装了。
4.3.1.3、指针使用三部曲：定义指针变量、关联指针变量、解引用
(1)当我们int *p定义一个指针变量p时，因为p是局部变量，所以也遵循C语言局部变量的一般规律（定义局部变量并且未初始化，则值是随机的），所以此时p变量中存储的是一个随机的数字。
(2)此时如果我们解引用p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空间到底能不能访问不知道（也许行也许不行），所以如果直接定义指针变量未绑定有效地址就去解引用几乎必死无疑。
(3)定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪随意转了几圈然后开了一枪。
(4)指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方（就好象拿着枪瞄准目标的过程一样），指针的解引用是为了间接访问目标变量（就好象开枪是为了打中目标一样）

4.3.2.指针带来的一些符号的理解
我们写的代码是给编译器看的，代码要想达到你想象的结果，就必要编译器对你的代码的理解和你自己对代码的理解一样。编译器理解代码就是理解的符号，所以我们要正确理解C语言中的符号，才能像编译器一样思考程序、理解代码。
4.3.2.1、星号*
(1)C语言中*可以表示乘号，也可以表示指针符号。这两个用法是毫无关联的，只是恰好用了同一个符号而已。
(2)星号在用于指针相关功能的时候有2种用法：第一种是指针定义时，*结合前面的类型用于表明要定义的指针的类型；第二种功能是指针解引用，解引用时*p表示p指向的变量本身

4.3.2.2、取地址符&
(1)取地址符使用时直接加在一个变量的前面，然后取地址符和变量加起来构成一个新的符号，这个符号表示这个变量的地址。

4.3.2.3、指针定义并初始化、与指针定义然后赋值的区别
(1)指针定义时可以初始化，指针的初始化其实就是给指针变量初值（跟普通变量的初始化没有任何本质区别）。
(2)指针变量定义同时初始化的格式是：int a = 32; int *p = &a;
(2)不初始化时指针变量先定义再赋值：int a = 32; int *p; 	p = &a;		正确的
														*p = &a;	错误的
4.3.2.4、左值与右值
(1)放在赋值运算符左边的就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 = 右值;
(2)当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量的值，也就是这个变量所对应的内存空间中存储的那个数。
(3)左值与右值的区别，就好象现实生活中“家”这个字的含义。譬如“我回家了”，这里面的家指的是你家的房子（类似于左值）；但是说“家比事业重要”，这时候的家指的是家人（家人就是住在家所对应的那个房子里面的人，类似于右值）

4.3.3.野指针问题
4.3.3.1、神马是野指针？哪里来的？有什么危害？
(1)野指针，就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）
(2)野指针很可能触发运行时段错误（Sgmentation fault）
(3)因为指针变量在定义时如果未初始化，值也是随机的。指针变量的值其实就是别的变量（指针所指向的那个变量）的地址，所以意味着这个指针指向了一个地址是不确定的变量，这时候去解引用就是去访问这个地址不确定的变量，所以结果是不可知的。
(4)野指针因为指向地址是不可预知的，所以有3种情况：

第一种是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种算是最好的情况了；

第二种是指向一个可用的、而且没什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的；

第三种情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量x），那么野指针的解引用就会刚好修改这个变量x的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。
(5)指针变量如果是局部变量，则分配在栈上，本身遵从栈的规律（反复使用，使用完不擦除，所以是脏的，本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值），就决定了栈的使用多少会影响这个默认值。因此野指针的值是有一定规律不是完全随机，但是这个值的规律对我们没意义。因为不管落在上面野指针3种情况的哪一种，都不是我们想看到的。

4.3.3.2、怎么避免野指针？
(1)野指针的错误来源就是指针定义了以后没有初始化，也没有赋值（总之就是指针没有明确的指向一个可用的内存空间），然后去解引用。
(2)知道了野指针产生的原因，避免方法就出来了：在指针的解引用之前，一定确保指针指向一个绝对可用的空间。
(3)常规的做法是：
	第一点：定义指针时，同时初始化为NULL
	第二点：在指针解引用之前，先去判断这个指针是不是NULL
	第三点：指针使用完之后，将其赋值为NULL
	第四点：在指针使用之前，将其赋值绑定给一个可用地址空间
(4)野指针的防治方案4点绝对可行，但是略显麻烦。很多人懒得这么做，那实践中怎么处理？在中小型程序中，自己水平可以把握的情况下，不必严格参照这个标准；但是在大型程序，或者自己水平感觉不好把握时，建议严格参照这个方法。

4.3.3.3、NULL到底是什么？
(1)NULL在C/C++中定义为：
#ifdef _cplusplus			// 定义这个符号就表示当前是C++环境
#define NULL 0				// 在C++中NULL就是0
#else
#define NULL (void *)0		// 在C中NULL是强制类型转换为void *的0
#endif

(2)在C语言中，int *p;你可以p = (int *)0;但是不可以p = 0;因为类型不相同。
(3)所以NULL的实质其实就是0，然后我们给指针赋初值为NULL，其实就是让指针指向0地址处。为什么指向0地址处？2个原因。第一层原因是0地址处作为一个特殊地址（我们认为指针指向这里就表示指针没有被初始化，就表示是野指针）；第二层原因是这个地址0地址在一般的操作系统中都是不可被访问的，如果C语言程序员不按规矩（不检查是否等于NULL就去解引用）写代码直接去解引用就会触发段错误，这种已经是最好的结果了。
(4)一般在判断指针是否野指针时，都写成
	if (NULL != p)
而不是写成 if (p != NULL)
原因是：如果NULL写在后面，当中间是==号的时候，有时候容易忘记写成了=，这时候其实程序已经错误，但是编译器不会报错。这个错误（对新手）很难检查出来；如果习惯了把NULL写在前面，当错误的把==写成了=时，编译器会报错，程序员会发现这个错误。

4.3.4.const关键字与指针
4.3.4.1、const修饰指针的4种形式
(1)const关键字，在C语言中用来修饰变量，表示这个变量是常量。
(2)const修饰指针有4种形式，区分清楚这4种即可全部理解const和指针。
	第一种：const int *p;
	第二种：int const *p;
	第三种：int * const p;
	第四种：const int * const p;
(3)关于指针变量的理解，主要涉及到2个变量：第一个是指针变量p本身，第二个是p指向的那个变量(*p)。一个const关键字只能修饰一个变量，所以弄清楚这4个表达式的关键就是搞清楚const放在某个位置是修饰谁的

4.3.4.2、const修饰的变量真的不能改吗？
(1)课堂练习说明：const修饰的变量其实是可以改的（前提是gcc环境下）。
(2)在某些单片机环境下，const修饰的变量是不可以改的。const修饰的变量到底能不能真的被修改，取决于具体的环境，C语言本身并没有完全严格一致的要求。
(3)在gcc中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。
(4)更深入一层的原因，是因为gcc把const类型的常量也放在了data段，其实和普通的全局变量放在data段是一样实现的，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，所以只要骗过编译器就可以修改了。

4.3.4.3、const究竟应该怎么用
(1)const是在编译器中实现的，编译时检查，并非不能骗过。所以在C语言中使用const，就好象是 一种道德约束而非法律约束，所以大家使用const时更多是传递一种信息，就是告诉编译器、也告诉读程序的人，这个变量是不应该也不必被修改的。

4.3.5.深入学习一下数组
4.3.5.1、从内存角度来理解数组
4.3.5.2、从编译器角度来理解数组
4.3.5.3、数组中几个关键符号（a a[0] &a &a[0]）的理解

4.3.6.指针与数组的天生姻缘
4.3.6.1、以指针方式来访问数组元素
4.3.6.2、从内存角度理解指针访问内存的实质
4.3.6.3、指针和数组类型的匹配问题
4.3.6.4、总结：指针类型决定了指针如何参与运算

4.3.7.指针与强制类型转换

4.3.8.指针、数组与sizeof运算符

4.3.9.指针与函数传参

4.3.10.输入型参数与输出型参数
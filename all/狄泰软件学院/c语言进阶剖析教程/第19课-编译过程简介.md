# 第19课-编译过程简介

```c
**/* 19-1.c */**
#include<stdio.h>

#define HELLO "helloworld！"

#define SUM(a,b) a+b;

int main(){

	int a = 1;
	int b = 2;
	int s = 0;
	char* p = HELLO;

	s = SUM(a,b);
	printf("%d\n",s);

	
	return 0;
}
```

```c
**/*
	1、预处理(.c-->.i)
	      替换#开头、注释等
	gcc -E 19-1.c -o 19-1.i
*/**
# 8 "19-1.c"
int main(){

 int a = 1;
 int b = 2;
 int s = 0;
 char* p = "helloworld\A3\A1";//被替换

 s = a+b;//被替换
 printf("%d\n",s);
```

```c
**/***
	**2、编译(.c/.i--->.S)
	     翻译内容成汇编代码
	gcc -S 19-1.c -o 19-1.S
	gcc -S 19-1.i -o 19-1.S
*/**
.section	.rodata
.LC0:
	.string	"helloworld\243\241"
.LC1:
	.string	"%d\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp
	movl	$1, -20(%rbp)
	movl	$2, -16(%rbp)
	movl	$0, -12(%rbp)
	movq	$.LC0, -8(%rbp)
	movl	-20(%rbp), %edx
	movl	-16(%rbp), %eax
	addl	%edx, %eax
	movl	%eax, -12(%rbp)
	movl	-12(%rbp), %eax
	movl	%eax, %esi
	movl	$.LC1, %edi
	movl	$0, %eax
	call	printf
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```

```c
	**3、汇编(.c\.i\.S-->.o)
		-使用：
           gcc -c 19-1.S -o 19-1.o
           gcc -c 19-1.i -o 19-1.o
           gcc -c 19-1.c -o 19-1.o
		-汇编代码转换为机器指令
		-每条汇编代码都对应一条机器指令**
```

![%E7%AC%AC19%E8%AF%BE-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B%207e9c51855a224504b561eae57446c167/Untitled.png](https://cdn.jsdelivr.net/gh/chenliang1301/Images@main/NotesImages/202111162236994.png)

4、链接(.c\.i\.S\.- →.out）

      **gcc 19-1.o -o 19-1**
    
      **gcc 19-1.S -o 19-1**
    
      **gcc 19-1.i -o 19-1**
    
      **gcc 19-1.c -o 19-1**
    
      将汇编代码翻译为机器指令的目标文件(可执行文件)
# 4.1.内存这个大话题

### 《4.1.内存这个大话题》

第一部分、章节目录
4.1.1.程序运行为什么需要内存1
4.1.1.1、计算机程序运行的目的
4.1.2.程序运行为什么需要内存2
4.1.3.位、字节、半字、字的概念和内存位宽
4.1.4.内存编址和寻址、内存对齐
4.1.5.C语言如何操作内存
4.1.6.内存管理之结构体
4.1.7、内存管理之栈
4.1.8、内存管理之堆
第二部分、章节介绍
4.1.1.程序运行为什么需要内存1
4.1.2.程序运行为什么需要内存2
4.1.3.位、字节、半字、字的概念和内存位宽
4.1.4.内存编址和寻址、内存对齐
4.1.5.C语言如何操作内存
4.1.6.内存管理之结构体
4.1.7、内存管理之栈
4.1.8、内存管理之堆
第三部分、随堂记录
4.1.1.程序运行为什么需要内存
4.1.1.1、计算机程序运行的目的
1、程序的目的是为了去运行，程序运行是为了得到一定的结果。
2、计算机程序 = 代码 + 数据
计算机程序运行完得到一个结果，就是说：代码 + 数据 (经过运行后) = 结果

从宏观上来理解，代码就是动作，就是加工数据的动作；数据就是数字，就是被代码所加工的东西？？？？
3、那么可以得出结论：程序运行的目的不外乎2个：结果、过程
4、用函数来类比：
函数的形参就是待加工的数据（函数内还需要一些临时数据，就是局部变量），     

函数本体就是代码，
函数的返回值就是结果，

函数体的执行过程就是过程。

```c
int add(int a, int b)
{
  return a + b;
}	// 这个函数的执行就是为了得到结果
void add(int a, int b)
{
	int c;
	c = a + b;
	printf("c = %d.\n", c);
}	// 这个函数的执行重在过程（重在过程中的printf），返回值不需要
int add(int a, int b)
{
	int c;
	c = a + b;
	printf("c = %d.\n", c);
	return c;
}	// 这个函数又重结果又重过程
```

4.1.1.2、计算机程序运行过程
  1计算机程序的运行过程，其实就是程序中很多个函数相继运行的过程。程序是由很多个函数组成的，程序的本质就是函数，函数的本质是加工数据的动作。
4.1.1.3、冯诺依曼结构和哈佛结构
  1、冯诺依曼结构是：数据和代码放在一起。
  2、哈佛结构是：数据和代码分开存在。
    1）代码：函数
    2）数据：全局变量、局部变量

      冯诺依曼结构：在S5PV210中运行的linux系统上，运行应用程序时：这时候所有的应用程序的代码和数据都在DRAM；

      哈佛结构：在单片机中，我们把程序代码烧写到Flash（NorFlash）（只读，不能改写）中，然后程序在Flash中原地运行，程序中所涉及到的数据（全局变量、局部变量）不能放在Flash中，必须放在RAM（SRAM）中。

   1、ROM(Read Only Memory)：断电任然可以保持数据。只读存储器。

   2、RAM(Read Access Memory)：断电丢失数据。随机存储器。

   2.1、SRAM(Static RAM)：读写快,贵

   2.2、DRAM(Dynamic DAM):读写慢，便宜

   3、FLASH：(闪存)：可檫除、不会断电丢失数据，可快速读取数据。     

4.1.1.4、动态内存DRAM和静态内存SRAM
  DRAM是动态内存，SRAM是静态内存。
4.1.1.5、总结：为什么需要内存呢
  1、内存是用来存储可变数据的，数据在程序中表现为全局变量、局部变量等（在gcc中，其实常量也是存储在内存中的）（大部分单片机中，常量是存储在flash中的，也就是在代码段）对我们写程序来说非常重要，对程序运行更是本质相关。

  2、所以内存对程序来说几乎是本质需求。越简单的程序需要越少的内存，而越庞大越复杂的程序需要更多的内存。内存管理是我们写程序时很重要的话题。我们以前学过的了解过的很多编程的关键其实都是为了内存，譬如说

  2.1、数据结构（数据结构是研究数据如何组织的，数据是放在内存中的）和

  2.2、算法（算法是为了用更优秀更有效的方法来加工数据，既然跟数据有关就离不开内存）。

4.1.1.6、深入思考：如何管理内存（无OS时，有OS时）
  1、对于计算机来说，内存容量越大则可能性越大，所以大家都希望自己的电脑内存更大。我们写程序时如何管理内存就成了很大的问题。如果管理不善，可能会造成程序运行消耗过多的内存，这样迟早内存都被你这个程序吃光了，当没有内存可用时程序就会崩溃。所以内存对程序来说是一种资源，所以管理内存对程序来说是一个重要技术和话题。
  2、先从操作系统角度讲：操作系统掌握所有的硬件内存，因为内存很大，所以操作系统把内存分成1个1个的页面（其实就是一块，一般是4KB），然后以页面为单位来管理。页面内用更细小的方式来以字节为单位管理。操作系统内存管理的原理非常麻烦、非常复杂、非常不人性化。那么对我们这些使用操作系统的人来说，其实不需要了解这些细节。操作系统给我们提供了内存管理的一些接口，我们只需要用API即可管理内存。譬如在C语言中使用malloc free这些接口来管理内存。

  3、没有操作系统时：在没有操作系统（其实就是裸机程序）中，程序需要直接操作内存，编程者需要自己计算内存的使用和安排。如果编程者不小心把内存用错了，错误结果需要自己承担。

  4、再从语言角度来讲：不同的语言提供了不同的操作内存的接口。
  4.1、譬如汇编：根本没有任何内存管理，内存管理全靠程序员自己，汇编中操作内存时直接使用内存地址（譬如0xd0020010），非常麻烦；

  4.2、譬如C语言：C语言中编译器帮我们管理直接内存地址，我们都是通过编译器提供的变量名等来访问内存的，操作系统下如果需要大块内存，可以通过API（malloc free）来访问系统内存。裸机程序中需要大块的内存需要自己来定义数组等来解决。

  4.3、譬如C++语言：C++语言对内存的使用进一步封装。我们可以用new来创建对象（其实就是为对象分配内存），然后使用完了用delete来删除对象（其实就是释放内存）。所以C++语言对内存的管理比C要高级一些，容易一些。但是C++中内存的管理还是靠程序员自己来做。如果程序员new了一个对象，但是用完了忘记delete就会造成这个对象占用的内存不能释放，这就是内存泄漏。

  4.4、Java/C#等语言：这些语言不直接操作内存，而是通过虚拟机来操作内存。这样虚拟机作为我们程序员的代理，来帮我们处理内存的释放工作。如果我的程序申请了内存，使用完成后忘记释放，则虚拟机会帮我释放掉这些内存。听起来似乎C# java等语言比C/C++有优势，但是其实他这个虚拟机回收内存是需要付出一定代价的，所以说语言没有好坏，只有适应不适应。1）当我们程序对性能非常在乎的时候（譬如操作系统内核）就会用C/C++语言；2）当我们对开发程序的速度非常在乎的时候，就会用Java/C#等语言。

4.1.3.位、字节、半字、字的概念和内存位宽

4.1.3.1、什么是内存？

  1、硬件角度：内存条

  2、逻辑角度：给个地址，可访问内存，可读写，存放变量，一个变量对应内存中一个单元
4.1.3.1、内存的逻辑抽象图

  1、？？====================== 2019 10月 26号 ===============
4.1.3.2、位和字节

  内存单元大小单位：位（1bit）、字节（8bit）
4.1.3.3、字和半字

  半字、字、双字：依赖平台

  RAM+LINUX:字32位
4.1.3.4、内存位宽

  1、硬件角度：有些内存条为8位，有些16位

  2、逻辑角度：任意，由于受硬件限制，一般为32位。
4.1.3.5、内存的编程模型

4.1.4.内存编址和寻址、内存对齐
4.1.4.1、内存编址方法

  1、逻辑上，内存是一个个格子（空间），可用来装数据，每个格子（空间）对应一个内存地址。

  2、程序运行只关心内存地址，因为硬件保证按照地址一定能找到格子（空间）

4.1.4.2、关键：内存编址是以字节为单位的

  1、一个内存地址大小一个字节（8bit）

4.1.4.3、内存和数据类型的关系

  1、32位系统中，定义int变量效率最高,int32位与计算机位宽一致。

  2、结构体为什么要四字对齐。数据总线32位意味着一次可读写4byte，提高效率。

4.1.4.4、内存对齐

  1、内出对齐很配合硬件，效率高。

4.1.4.5、从内存编址看数组的意义

  1、

4.1.5.C语言如何操作内存

4.1.5.1、C语言对内存地址的封装（用变量名来访问内存、数据类型的含义、函数名的含义）

  1、数据类型的本质：一个内存格子的长度和解析方法

  1.1、长度：地址0x30000000，表示1bit长度，但int类型，能表示0x30000000、0x30000001、0x30000002和0x30000003，4bit长度

  1.2、解析方法：数据类型决定解析方法，根据内存地址不同类型指定内存单元二进制的解析方法。

     如：（int）0x3000 0000,含义就是（0x3000 0000 + 0x3000 0001 + 0x3000 0002 + 0x3000 0003）这四个字节共同存储的是一个int型数据

   （int *）0;

    (float *)0;

    (short)0;

    (char)0;

  值都一样，解析方式不同

  2、C语言中，函数就是一段代码的封装。函数名的实质是这一段代码的首地址。

     函数名的本质也是一个内存地址。

4.1.5.2、用指针来间接访问内存

  1、关于类型：只是对后面数字或者符号（内存地址）所表征的内存的一种长度规定和解析方法。

  2、int a 与 int *p;

    2.1、a与p代表内存地址（设0x2000 0000）

    2.2、a是int类型，的长度是4个字节，解析方式按照int规定。

    2.3、p是int *类型，长度4byte，解析方式int *规定（0x2000 0000开头连续四个字节存储一个地址，地址所代表的内存单元中存放的是一个int类型的数）。     
4.1.5.3、指针类型的含义
4.1.5.4、用数组来管理内存

    1、数组管理内存和变量其实没有区别，只是解析方式不同

    如：int a；//编译器分配四个字节长度给a，并把首地址与a绑定起来

       int b[10];//编译器分配40字节长度给b，并把首元素的首地址和符号b绑定起来

4.1.6.内存管理之结构体
4.1.6.1、数据结构这门学问的意义

  数据结构就是研究数据如何组织（在内存中排布），如何加工的学问

4.1.6.2、最简单的数据结构：数组

  数组意义：类型相同、意义相关。

  如：int age[20];

4.1.6.3、数组的优势和缺陷

  优势：int ages[20];

  缺陷：1数组中所有元素必须相同；2数组大小必须定义时给出，而且一旦确定不能再改。

4.1.6.4、结构体隆重登场

  结构体是为了解决数组的第一个缺陷，数组中所有元素类型必须相同。

  如：struct people 

     {
          int age;

          char *name;

          double height;
     }

4.1.6.5、题外话：结构体内嵌指针实现面向对象

  C语言写出的linux系统是面向对象的。

```c
struct s
{
	int age;  
  void (*pFunc)(void);  //函数指针，指向void func（void）这类的函数
}
```

  包含了函数指针的结构体可以实现面向对象。
  结构体中的变量类似于class中的成员变量，结构体中的函数指针类似于class中的成员方法。

4.1.7、内存管理之栈（stack）
4.1.7.1、什么是栈
   栈是一种数据结构，C语言中使用栈来保存局部变量。栈发明是用来管理内存的。
1.4.7.2、栈管理内存的特点（小内存、自动化）
   栈：先进后出 FILO    first in last out   如：死胡同，零件
   特点：入口即出口，只有一个口，另一个口堵死。陷进去后出来

   队列：先进先出 FIFO  first in first out  如：排队
   特点：必须从入口进，从出口出，先进去必须先出来，否则堵死

1.4.7.3、栈的应用举例：局部变量

  C语言中的局部变量是用栈来实现的。

  如：我们C中顶一个局部变量（int a）,编译器会在栈中分配一段空间（4字节）给局部变量用（分配时栈顶指针会移动给出空间，给局部变量a，将4字节的栈内存地址和我们定义的局部变量a关联起来），对应栈的操作时入栈。

  注意：这里栈指针的移动和内存分配是自动的（栈自己完成，不用我们代码操作）。

  然后：等我们函数退出时候，局部变量要灭亡。对应栈的操作室弹栈（出栈）。出站时也是栈顶指针移动将栈空间中与a关联的那4个字节空间释放。这个动作也是自动，不用人写代码干预。

  栈优点：栈管理内存，方便，分配和回收C自动完成。

  细节：C语言中，定义局部变量如果没有初始化，值是随机的，为什么？

  1定义局部变量，其实就是栈中通过移动指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏，上次用完没清零），栈来实现就不变量时如果不显式初始化，值是脏的。

  2、C语言是通过小手段实现局部变量的初始化

    

```c
int a = 15; //局部变量定义时初始化
```

 C语言编译器会自动把这行转成：

```c
int a;
a = 15;
```

  
1.4.7.4、栈的约束（预定栈大小不灵活，怕溢出）

  1、栈有大小。栈大小不好设置。太小溢出，太大浪费内存。（像数组缺点）

  2、栈溢出危险很大，一定要避免。

    不能定义局部变量 int a[100000]  使用递归解决问题一定要注意递归收敛

4.1.8、内存管理之堆
4.1.8.1、什么是堆

  堆（heap）是一种内存管理方式。内存管理对操作系统来说是一件非常复杂的事情，因为首先内存容量很大，其次内存需求在时间和大小快上没有规律（操作系统上运行着几十、几千进程随时释放，申请和释放的内存大小随意）。

  栈这种内存管理方式特点就是自由（随时申请、释放；大小快随意）。堆内存是操作系统划归给堆管理器（操作系统中的一段代码，属于操作系统的内存管理单元）来管理的，然后向使用者（用户进程）提供API（malloc和free）来使用堆内存。

  什么时候使用堆内存？需要内存容量比较大时，需要反复使用及释放时，很多数据结构（譬如链表）的实现都需要使用堆内存。
4.1.8.2、堆管理内存的特点（大块内存、手工分配&使用&释放）

  特点一：容量不限（常规使用的需求容量都能满足）。

  特点二：申请和释放都需要手工进行，明确申请malloc及释放free。如果程序员申请内存使用后未释放，这段内存就丢失了（在堆管理器的记录中，这段内存任然属于你这个进程，但进程自己以为这段内存已经不用了，再用时候又回去申请新的内存块，这叫吃内存），称为内存泄漏。在C/C++语言中，内存泄漏是最严重的的程序bug，这也是别人认为Java/C#等语言比C/C++优秀的地方。

4.1.8.3、C语言操作堆内存的接口（malloc free）

  内存释放时最简单，直接调用free释放即可。 void free(void *ptr);

  堆内存申请时，有3个可选择的类似功能的函数：malloc、calloc、recalloc

```c
void *malloc(size_t size);
void *calloc(size_t nmemb, size_t size);  //nmemb个单元，每个单元size字节
void *realloc(void *ptr, size_t size);  // 改变原来申请的空间的大小
```

  如：申请10个int元素内存

```c
malloc(40);  malloc(10*sizeof(int));
calloc(10,4); calloc(10,sizeof(int));
```

  数组定义时必须给出数组元素个数（数组大小），而一旦定义再无法更改。在Java等高级语言中，有一些愈发技巧可以更改数组大小，但其实是障眼法。工作原理：先创建一个新数组大小为要更改后的数组，然后将原数组的所有元素复制进新数组，然后释放掉原数组，最后返回新的数组给用户。

  堆内存申请时必须给定大小，然后一旦申请完成大小不变，如果要变只能通过realloc接口。relloc的实现原理类似于上面说的Java中的可变大小的数组方式。

4.1.8.4、堆的优势和劣势（管理大块内存、灵活、容易内存泄漏）

  优势：灵活。

  劣势：需要程序员去处理各种细节，所以容易出错，严重依赖程序员的水平。

4.1.9、复杂数据结构

4.1.9.1、链表、哈希表、二叉树、图等

  链表是最重要的，链表在linux内核中使用非常多，驱动、应用编写很多时候都需要使用链表，所以对链表必须掌握，会自己定义结构体来实现链表、会写链表的节点插入（前插、后插）、节点删除、节点查找、节点遍历等。（至于像逆序这些很少用，掌握了前面，这个也不难）。——————80%

  哈希表不是常用，一般不需要自己写实现，而直接使用别人实现的哈希表比较多。对我们来说最重要的是要明白，别人为什么要用哈希表、合适不合适？有没有更好的选择？—————15%

二叉树、图等。对于这些复杂数据结构，不要太当回事。这些复杂结构用到的概率很小（在嵌入式开发中）其实这些数据结构发明出来就是为了解决特定问题，不处理特定问题，根本用不到。没必要去研究。—————5%

4.1.9.2、为什么需要更复杂的数据结构

  因为现实中实际问题是多种多样的，问题的复杂度不同，所以需要解决问题的算法和数据结构也不同。所以当你处理什么复杂的问题，就去研究针对性解决的数据结构和算法；

4.1.9.3、数据结构和算法的关系

  数据结构的发明都是为了配合一定的算法；算法是为了处理具体问题，算法的实现依赖于响应的数据结构。

  当前我们说的算法和纯数学是不同的（算法是基于数学的）因为计算机算法为指导，并结合计算机本身特点来改进，最终实现一个在计算机上可以运行的算法（用代码表示）

4.1.9.4、应该怎样学习者部分？

  从上面表述应该明白

   1、数据结构和算法是相辅相成的，要一起研究

   2、数据结构和算法对嵌入式不是重点，不要盲目学习

   3、一般实际应用中，实现数据结构和算法的人使用数据结构和算法是分开的。实际中有一部分人的工作就是研究数据结构和算法，并试图用代码来实现这些算法（表现为库），其他做真正工作的人要做的就是理解 、明白这些算法和数据结构的意义、优劣、特征，然后合适时候选择合适数据结构和算法来解决自己碰到的实际问题。

  例子：linux内核在字符设备驱动管理时，使用哈希表（hash table。散列表）。所以字符设备驱动的很多特点都和哈希表有关。
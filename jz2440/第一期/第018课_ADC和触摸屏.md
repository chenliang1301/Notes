# 第018课_ADC和触摸屏

第001节_ADC硬件原理

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled-1636555251223.png)

如：可调电阻电压值变换的模拟信号通过ADC转换，输出数字信号。

1、如何启动ADC？

2、启动ADC如何得到数据？

一、编程流程

- 信号通道8选1
- 设置工作时钟
- 启动
- 读状态，判断ADC转换时否成功
- 读数据

二、寄存器功能

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%201.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 1-1636555255292.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%202.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 2-1636555256586.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%203.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 3-1636555261043.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%204.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 4-1636555262504.png)

第002节_ADC编程

编程步骤

- 初始化ADC
- 读数据
- 串口显示

一、初始化ADC

```c
void adc_init(void)
{
		/*  prescaler enable
				prescaler value
				Analog input channel select
		 */
    ADCCON = (1<<14)|(49<<6)|(0<<3); 

    ADCDLY = 0xff;//delay
}
```

二、读数据

```c
int adc_read_ain0(void)
{
    ADCCON |=(1<<0);//conversion start read boot
    
    while(!(ADCCON & (1<<15)));//wait read end
    
    return (ADCDAT0 & 0x3ff);//conversion value
}
```

三、串口显示

```c
void adc_test(void)
{

    int val = 0;
    double vol = 0;
    int m = 0;
    int n = 0;
    adc_init();
    while(1)
    {
        val = adc_read_ain0();        
        vol = (double)val/1023*3.3;        
        m = (int)val;
        vol = vol - m;
        n = vol * 1000;//0.234 * 1000 = 234
        printf("vol:%03d.%0d\r",m,n);//dynamic display
    }
}
```

第003节_电阻触摸屏硬件原理

一、工作原理：两层电阻膜，一边上电，另一边不上电。分开测（x,y）

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%205.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 5-1636555266101.png)

二、等待中断模式的等效电路,控制开关

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%206.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 6-1636555267881.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%207.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 7-1636555269881.png)

三、寄存器

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%208.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 8-1636555271638.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%209.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 9-1636555273693.png)

1、indicate ADC/TC status

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2010.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 10-1636555275039.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2011.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 11-1636555276424.png)

2、mask  ADC/TC interrupt

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2012.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 12-1636555278234.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2013.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 13-1636555279678.png)

3、indicate INT_ADC interrupt status

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2014.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 14-1636555281054.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2015.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 15-1636555283043.png)

4、mask INT_ADC interrupt 

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2016.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 16-1636555284549.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2017.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 17-1636555286416.png)

5、interrupt mode

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2018.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 18-1636555287813.png)

```c
//adc_touchscreen.c
#include "../s3c2440_soc.h"

#define ADC_INT_BIT            (10)
#define TC_INT_BIT             (9)
#define INT_ADC_TC             (31)

/* ADCTSC's bits */
#define WAIT_PEN_DOWN          (0<<8)
#define WAIT_PEN_UP            (1<<8)

#define UP_DOWN_STATIC         (8)

#define YM_ENABLE              (1<<7)
#define YM_DISABLE             (0<<7)

#define YP_ENABLE              (0<<6)
#define YP_DISABLE             (1<<6)

#define XM_ENABLE              (1<<5)
#define XM_DISABLE             (0<<5)

#define XP_ENABLE              (0<<4)
#define XP_DISABLE             (1<<4)

#define PULL_ENABLE            (0<<3)
#define PULL_DISABLE           (1<<3)

#define AUTO_PST               (1<<2)

#define WAIT_INT_MODE          (3)

#define NO_OPERATION_MODE      (0)

void enter_wait_pen_down_mode(void)
{
    ADCTSC = WAIT_PEN_DOWN | PULL_ENABLE | YM_ENABLE | XP_DISABLE | YP_DISABLE | XM_DISABLE | WAIT_INT_MODE;  
}

void enter_wait_pen_up_mode(void)
{
    ADCTSC = WAIT_PEN_UP | PULL_ENABLE | YM_ENABLE | XP_DISABLE | YP_DISABLE | XM_DISABLE | WAIT_INT_MODE;  
}

void Isr_Tc(void)
{
    printf("ADCUPDN = 0x%x\tADCTSC = 0x%x\tADCDAT0 = 0X%x\tADCDAT1 = 0x%x\tADCCON = 0x%x\n\r",ADCUPDN,ADCTSC,ADCDAT0,ADCDAT1,ADCCON);    
    
    if(ADCDAT0 & (1<<15))
    {
        printf("pen up\n\r");   
        enter_wait_pen_down_mode();
    }
    else
    {
        printf("pen down\n\r");
        enter_wait_pen_up_mode();
    }
}

void AdcTcIntHandle(int irq)
{
    if(SUBSRCPND & (1<<TC_INT_BIT))//touch screen press
       Isr_Tc();   
    /* clean interrupt */    
    //INTSUBMSK = ((1<<TC_INT_BIT) | (1<<ADC_INT_BIT));   //already clean 
    SUBSRCPND = (1<<TC_INT_BIT) | (1<<ADC_INT_BIT);    
    /*
    if(SUBSRCPND & (1<<ADC_INT_BIT)) //adc boot
    {
        Isr_Adc();         
    }
    */
}

void adc_tc_reg_init(void)
{
    ADCCON = (1<<14) | (49<<6) | (0<<3); //prescaler,Analog input channel select

    ADCDLY = 0xff;//delay
}

void adc_ts_int_init(void)
{
    /* registe interrupt function */
    register_irq(INT_ADC_TC,AdcTcIntHandle);

    /* enable interrupt : ADC/TC/SENT*/
    INTSUBMSK &= ~((1<<TC_INT_BIT) | (1<<ADC_INT_BIT));
//    INTMSK    &= ~((1<<32);
}

void touchscreen_init(void)
{
       /* clean interrupt */  
//    SUBSRCPND = (1<<TC_INT_BIT) | (1<<ADC_INT_BIT);    
    
    /* set ADC/TC interface : register */
    adc_tc_reg_init();
         
    //printf("ADCUPDN = 0x%x\tSUBSRCPND = 0x%x\tADCCON = 0X%x\tSRCPND = 0x%x\n\r",ADCUPDN,SUBSRCPND,ADCCON,SRCPND);         

    /* ADC/TC interrupt enable */
    adc_ts_int_init();

    /* wait interrupt mode */
    enter_wait_pen_down_mode();
}
```

enter_auto_measure_mode

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2019.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 19-1636555291887.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2020.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 20-1636555293191.png)

enable ADC

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2021.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 21-1636555294935.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2022.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 22-1636555296927.png)

read data

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2023.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 23-1636555298831.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2024.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 24-1636555300076.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2025.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 25-1636555301297.png)

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2026.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 26-1636555302889.png)

wait delay

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2027.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 27-1636555304655.png)

第006节_触摸编程_ADC中断

一、自动检测

```c
void enter_auto_measure_mode(void)
{
    ADCTSC = AUTO_PST ;// auto x y
}
```

二、中断处理函数

```c
void AdcTcIntHandle(int irq)
{
    if(SUBSRCPND & (1<<TC_INT_BIT))//touch screen interrupt
       Isr_Tc();   
     
    if(SUBSRCPND & (1<<ADC_INT_BIT)) //adc interrupt
       Isr_Adc();      
    
    //INTSUBMSK = ((1<<TC_INT_BIT) | (1<<ADC_INT_BIT));   //already clean 
    SUBSRCPND = (1<<TC_INT_BIT) | (1<<ADC_INT_BIT);          /* clean interrupt */    
}
```

三、触摸屏中断

```c
void Isr_Tc(void)
{
    //printf("ADCUPDN = 0x%x\tADCTSC = 0x%x\tADCDAT0 = 0X%x\tADCDAT1 = 0x%x\tADCCON = 0x%x\n\r",ADCUPDN,ADCTSC,ADCDAT0,ADCDAT1,ADCCON);    
    
    if(ADCDAT0 & (1<<15))
    {
        //printf("pen up\n\r");   
        enter_wait_pen_down_mode();
    }
    else
    {
        //printf("pen down\n\r");
        enter_auto_measure_mode();
        ADCCON |= (1<<0);//enable adc
    }
}
```

四、ADC中断

```c
void Isr_Adc(void)
{
    int x = ADCDAT0 & 0x3ff;
    int y = ADCDAT0 & 0x3ff;    

    if(!(ADCDAT0 & (1<<15)))//down status
    {
         printf("(x=%d,y=%d)\n\r",x,y);
    }
   
    //printf("(x=0x%08x,y=0x%08x)\n\r",x,y);    

    enter_wait_pen_up_mode();
}
```

五、ADCDLY

```c
void adc_tc_reg_init(void)
{
    ADCCON = (1<<14) | (49<<6) | (0<<3); //prescaler,Analog input channel select

    /* pess tc delay craet tc interrupt
     * delayTime = ADCDLY * jingzhen period = ADCDLY * 1 / 12 000 000 = 5ms
     *  5 / 1000 * 12 000 000 = 6 000
     *
     */

    ADCDLY = 6000;//delay
}
```

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2028.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 28-1636555309270.png)

六、电路图接反了？？？？？

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2029.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 29-1636555310832.png)

# 第007节_触摸屏编程_使用定时器改进

流程

​                                                                                                             

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2030.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 30-1636555312203.png)

第八节_触摸屏校准原理

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2031.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 31-1636555314623.png)

根据比例计算对应点的坐标值

第011节_触摸屏编程_测试

a.对于触摸屏要多次测量求平均值

b.要丢弃非法值（以LCD分辨率作为判断准备）

c.校准时一定要点准

第012节_触摸屏编程_完善

a.第一次点击触摸屏，会出现2个点

b.长按，LCD上的点会越来越大

根源：ADC转换出来的x ,y坐标值不稳定

![%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%2003bc36858d414c218c5d41affa93c51b/Untitled%2032.png](D:\08 git\notion\all\韦东山\第一期\images\Untitled 32-1636555316799.png)

修改要点：

1、启动ADC不要进入等待中断模式，他会影响数据

2、只有在"等待中断模式下"在可以使用ADCDAT0'bit15 来判断触摸屏 

3、校准非常重要，所以在程序中多次测量求平均值，不仅仅在ADC中断求平均值

参考 tslib：

a.使用矩阵进行校准，实用性更强

b.使用多种方法消除误差

多次测量求平均朱

判断相邻误差大，则为错误值